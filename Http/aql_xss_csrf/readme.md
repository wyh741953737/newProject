
一、SQL注入原理

    SQL注入主要是针对数据库的，几乎每个web应用都要用数据库操作所需各种信息，所以WEb程序经常会建立用户提交数据的SQL语句
    如果，建立这种语句的方法不安全，程序很容易收到SQL注入的攻击，最严重，SQL注入读取甚至修改数据库中保存的所有数据，用户可以提交一段数据库查询代码，根据查询返回的结果获取某些他想知道的数据
    SQL注入危害：
        探知数据库的具体结果，为进一步攻击做准备
        泄露数据，尤其是机密信息
        取得更高权限，来修改表数据甚至内部结构
        如家CSDN密码泄露，
    SQL注入防御：
        参数化查询：根本性的防御策略，也叫预处理语句，在建立一个包含用户输入SQL语句时分两步：
                    1：指定查询结构，用户输入预留占位符
                    2：指定占位符的内容

             
二、XSS攻击原理
        Cross Site Scripting 跨站脚本攻击，是一种经常出现在web应用中的计算机安全漏洞
        它允许恶意web用户将代码植入到其他用户使用的页面，其他用户在观看网页时候，恶意脚本就会执行。
        这类攻击通常通过注入HTML或js等脚本发起攻击（比如做个假的登陆界面—）
        攻击成功后，攻击者可以得到私密网页内容和Cookie等
    XSS攻击危害
        盗取各类用户账号
        控制数据，包括读取，篡改，添加删除企业敏感数据的能力
        非法转账
        控制受害者机器向其他网站发起攻击
    XSS案例：
        Myspace事件：存储式XSS攻击
            2005年，一名叫samy的用户发现Myspace的XSS漏洞，他在用户资料页面插入了一些javascript脚本，如果谁查看了他的用户资料，脚本就执行，脚本包含两方面内容：一是把samy加为好友，而是将上面说的脚本复制到受害者自己的用户资料页面中。（为了增加粉丝量）
            于是所有受害者用户资料的用户也会成为受害者
            一个基于存储式XSS攻击的蠕虫迅速扩散，几个小时内samy收到了近百万好友申请
            为此Myspace被迫关站，修复反XSS过滤机制并且从所有用户资料中删除含有恶意脚本的内容。
        Apache事件：反射式XSS攻击
            1：攻击者发布一个使用重定向服务进行模糊处理的链接，该链接指向一个利用XSS漏洞获取登录用户的会话令牌的url
            2：如果管理员点击该链接，其会话将被攻破，攻击者获得对应程序的管理访问权限
            3：攻击者修改项目的某个配置，将该项目的上传文件夹更改为应用程序的WEB根目录中可执行目录
            4：攻击者向此文件夹上传一个木马登录表单，从而获取特权用户的账户和密码（达到钓鱼攻击目的）


    XSS分类：
        反射式XSS：
            发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。
            是目前最流行的XSS攻击，她出现在服务器直接使用客户端提交的数据，如url的数据，html表单中的提交数据等，并且没有对数据进行无害化处理。如果提交的数据中含有html控制字符而没有被正确处理，那么一个简单的XSS攻击就会发生。典型的反射式攻击可通过一个邮件或者中间网站，诱饵是一个看起来吸引人的站点的连接，其中包含XSS攻击脚本，如果信任的网站没有正确处理这个脚本，用户点击后就会导致浏览器执行含有恶意攻击的脚本。
        存储式XSS：
            存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码
            最典型的例子是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，那些留言的内容会从数据库查询出来并显示，浏览器发现有XSS代码，就当做正常的HTML与Js解析执行，于是触发了XSS攻击。
            也成为永久性XSS，危害更大，不是最流行（非常容易留下痕迹，容易被清除）
        基于DOM的XSS攻击：
            DOM XSS和反射型XSS、存储型XSS的差别在于DOM XSS的代码并不需要服务器参与，触发XSS靠的是浏览器端的DOM解析，完全是客户端的事情。
            反射性XSS攻击和存储式XSS攻击都是通过服务端提取用户提交的数据，并且以不安全的方式将其返回给用户。基于DOM的攻击仅仅在前端通过javascript的方式执行。
    XSS攻击载荷（载荷？可能会攻击的地方）
        1：会话令牌，XSS攻击最普遍的方式。
        2：虚拟置换，这种攻击要在一个Web应用程序页面注入恶意数据，包括简单的向站点注入html，或者使用脚本注入精心设计的内容。
        3：注入木马，这种攻击造成的后果远比虚拟置换严重，如：弹出框告诉你用户信息登录失效重新登录。
    XSS防御措施：
        1：输入验证，若程序在某个位置收到用户提交的数据将来可能会被复制到其他响应中，程序根据这种情形对这些数据执行尽可能严格的确认（数据不是太长，数据仅包含某组合法字符，数据与一个特殊字符的正规表达式相匹配）。
        2：输出编码，若程序将某位用户或第三方提交的数据复制到他的响应中，那么程序应该对这些数据进行html编码，以净化可能的恶意字符。
        html编码指用对应的html实体代替字面量字符，这样做可确保浏览器安全处理可能为恶意的字符，把他们当作html文档的内容而非结构处理。
        两层防御程序能够获得额外的保护。输出确认最为重要，必不可少

三、CSRF（Cross-site Request Forgery）跨站请求伪造，也叫XSRF，：
        XSS利用站点内的信任用户（受害者），而CSRF通过伪装来自受信任用户的请求来利用受信任的网站。
        攻击方式：通过社会工程学的手段（如通过电子邮件发送一个链接）来蛊惑受害者进行一些敏感性的操作，如修改密码，修改E-mail，转账等，而受害者还不知道自己中招。
    CSRF攻击危害：
        CSRF的破坏力依赖于受害者的权限。如果受害者是普通用户，攻击后会危害用户的数据以及某些功能。如果有管理员权限，会威胁到整个网站的安全。
        与XSS相比，XSRF攻击不太流行（因此对其防御的资源也相当少）和难以防范
        古被认为比XSS更具危险性，所以XSRF在业内有个响当当的名字-沉睡的巨人。
    典型的CSRF攻击：
        A登录了一个金融网站，B发现这个网站的转账功能有CSRF漏洞，B在该网站发布了一条blog，这个blog支持img自定义功能，所以B插入了一行html代码<img src="http://mybank.com/transferMoney.jsp?to=B&cash=3000" width="1" height="1" border="0"/> A在自己浏览器打开了零一个变迁也正好督导这个blog，于是A的账户就不知不觉像B账户转了3000却不知道。
    攻击过程深度剖析：
        1：Web浏览器对Cookie和HTTP身份验证信息之类的绘画信息的处理方式：
            目前，浏览器会自动发送标识用户对话信息，而无需用户干预。
            换句话说，当浏览器发送这些身份信息的时候，用户根本感觉不到。假设站点A有一个Web应用程序，并且受害者正好已经在该站点上通过了身份认证，这时，相应消息中就会有Cookie来记录这个信息。
    CSRF攻击防御
        1：增加一些确认操作，比如弹出框“你确认转账？”
        2：重新认证，在做某些重要敏感操作的时候，要求用户重新输入密码进行二次验证，只有正确才进行操作。
        3：使用Token，在用户刚登陆的时候，产生一个新的不可阈值的CSRFToken，并且把此Token存放在用户的session中。在任何一个需要保护的表单中，增加一个隐藏字段来存放Token。提交此请求时服务端检查提交的Token和用户Session中的Token是否一致，不一致返回错误。在用户退出或者session过期，用户信息从session中移除并且销毁session
