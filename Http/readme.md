Http：超文本传输协议。允许将超文本标记语言文档从web服务器传送到客户端的浏览器

http协议历史：
1990.10 ：
    万维网之父TimBerners-lee最早提出了Http协议（完成三大基础设计：命名方案URI，通信协议http，表达信息的Html）实现了 webserver（客户端和服务器）
    1990年底可以在互联网上浏览，这个时候还没有版本。
1991 ：
     Http0.9诞生（鉴于Tim对互联网的贡献，将他写的关于http文章作为http的第一个版本）
     1994Tim成立了W3c
1996.05 Http1.0发布（增加了请求头响应头域，head，post方法，对象也不只是html文本，也支持一些长连接，缓存机制。等等）

1997.01 Http1.1发布（增加了options，delete，put，tress，connect，分块传输，管道机制
2015.5 Http2.0提出（http1.1的扩展

http3.0 QUIC协议（减少TCP带来的延迟和开销）

TCP面向连接（可靠性）
UDP面向无连接（不太可靠）

透过TCP/IP看Http
    Http协议是构建在Tcp/ip协议之上的，是Tcp/Ip的一个子集

    TCP/IP协议是一系列与互联网相关的协议集合起来的总称
    Tcp/Ip协议族分层：应用层（Http）、传输层（TCP）、网络层（IP）、数据链路层（网络）
        1：应用层：一般是我们编写的应用程序，决定了向用户提供的服务，应用层可以通过系统调用与传输层进行通信，比如FTP、DNS、HTTP等
        2：传输层：通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能（TCP/UDP）（TCP要建立连接所以效率低
        3：网络层：用来处理在网络上流动的数据包，该层规定了通过怎样的路径（传输路线）到达对方计算机，并把数据包传输给对方
        4：链路层：处理连接网络的硬件部分，包括控制操作系统、硬件设备驱动，网卡等
    数据包的封装：
        应用程序数据在发布到数据网络之前，每层协议都在上层协议基础上加上自己的头部信息，链路层还会加上一个尾部
    Http数据传输过程：
        发送数据：数据从上到下，且每经过一层都会被打上该层的头部信息
        接收数据：数据从下往上，传输前会把下层的头部信息删除
    作为发送端的客户端在应用层（通过Http协议发送一个请求），为了传输方便，在传输层（通过Tcp协议将应用层收到的数据，也就是报文进行分割，在各个报文打上标记序号，端口号等等一系列信息发送到网络层，网络层通过Ip协议增加作为通讯目的地的Mac地址，然后转发给链路层，接收端的服务端在数据链路层接收到请求数据，按顺序向上传递

    Tcp三次握手：
        1：客户端发送带有SYN标识（SYN=1，seq=x）的连接请求报文段，然后进入SYN_SEND状态，等待服务端确认。
        2：服务端接收到客户端SYN报文段后，需要发送ACK信息对这个SYN进行确认，同时还要发送自己的SYN信息（SYN=1，ACK=1，seq=y，ack=x+1）服务端把这些信息放在一个报文段中（（SYN+ACK报文段），一并发给客户端，此时客户端进入SYN_RECV状态
        3：客户端接收到服务端的SYN+ACK报文段后会向服务端发送ACK（ACK=1，seq=x+，ack=y+1）确认报文段，这个报文段发送后， 客户端和服务端都进入ESTABLISHED状态，完成三次握手。
        三次？双方要明确对方接收能力都是正常的，（客户端发之后，服务端可以确定客户端有发送能力，服务端发送给客户端，可以确定服务端的接收和发送能力正常，最后客户端发送确认，来确定客户端的接受能力

Http特点：
    1：支持客户/服务器模式（由客户端发出请求）
    2：简单快速，只要传送请求方法/路径（由于http协议简单，使得http服务器的程序规模小，因而通信速度很快
    3：灵活，http允许传输任意类型数据对象，由content-type加以标记（1.0后）
    4：无连接，每次连接只处理一个请求，服务器处理完客户端请求，并接收到客户端答应之后，就断开连接，采用这种方式可以节约时间。（keepalive：让客户端与服务端的连接持续有效，避免重新建立连接）
    5：无状态：协议对事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，导致每次传输数据很大

URI/URL
    URI（URL+URN）
    URI看可以分为URL，URN，同时具备locators和names特性的一个东西。URN就像一个人的名字，URL就像一个人的地址。
    URI可以被进一步分为定位符，名字或者两者都是
    URL（uniform Resource Locaator）除了确定一个资源，还提供一种定位该资源的主要访问机制。
URI和URL最大区别：访问机制不同
    ftp://ftp.is.io.za/rfc/1019.txt URL
    tel:020-1245-222  URI

Http报文结构：
    请求报文（报文头（请求方式，url，协议版本，host，content-Type，cookie，Connection），报文体）
    http报文头大体文为4类：
        通用报文头：
            cache-Control；控制缓存行为，
            connection:连接管理 keep-alive/close，
            Date：创建报文日期，
            Program:报文指令，
            Warning：错误通知，
            Via：代理服务器相关信息，
            Upgrade：升级为其他协议，

            Transfer-Encoding：指定报文主体传输的编码方式。
        请求报文头：
            Accept：用户代理可处理的媒体类型如text/html，
            Accept-Charset：优先字符集，
            Accept-Encoding：优先内容编码
            Accept-Language：优先语言
            Authorization：Web认证信息，
            Referer：对请求中URI的原始获取方
            Host：请求资源所在服务器，
            IF-match：比较实体标记（Etag），
            If-Modified-since：比较资源的更新时间，
            If-None-Match：与If-Match相反。
            If-Unmodified-since：与If-Modified-since相反，
        响应报文体：
        Accept-Ranges：是否接受字节范围请求
            Age：推算资源创建经过的时间，
            ETag：资源的匹配信息，
            Location：令客户端重定向的URI，
            Proxy-Authenticate代理服务器对客户端的认证信息
            Retry-After对再次发起请求的时机要求
            Server：Http服务器的安装信息，
            Vary：代理服务器缓存的管理信息
            WWW-Authenticate服务器对客户端的认证信息
        实体报文头
    
响应报文：
    响应头：
        Http/1.1 200 ok
        Server
        Date
        Cache-control：
        Expires
        Content-lengtth
        Content-type
    响应体

Http请求的方法：
  GET：用来访问已经被URI识别的资源，请求参数作为url的一部分（不能很大，浏览器对url有限制，IE最短2803，Chrome仅次于IE8182，firfox 65536，，safari80000.最长的opera。（安全性，长度
  POST：和GET不同的是，1：请求参数：get请求参数放在请求地址上，post放在请求头中，2：安全性：get请求参数在地址栏上可以看到，不安全。3：长度。
  PUT：PUT是幂等（任意多次执行产生的影响与一次执行的影响相同的），POST是不幂等的，没有验证机制
        更多时候将PUT方法作为传输资源
  Head：类似于GET，只不过返回的响应没有具体内容，指获取请求头
  DELETE，
  OPTIONS：用来查询针对请求URI指定的资源支持的方法（不知道对方支持什么方法的时候，问服务器我支持什么方法，响应放在ALLOW中，支持GET，POST，HEAD，DELETE，OPTIONS
  TRACE：回显服务器收到的请求，主要用于测试或诊断，（客户端可以通过Trace方法查询发送出去的请求到底是怎样被篡改。
  CONNECT：开启一个客户端与所请求资源之间双向沟通的通道，它可以用来创建隧道（HTTP代理的时候用的CONNECT

状态码：
    1**： 消息，请求已被接受，需要继续处理，这类响应是临时响应
    2**：成功
        （吃饭的例子：202：接受你请客但是还没去，206，去吃饭吃到一半走了，下次来原模原样弄回去）
        202：已经接受请求，但未完成
        206：部分内容，服务器成功处理了部分GET请求
    3**：重定向，需要客户端采取进一步操作才能完成请求。
        301：永久移动，请求资源已经被永久移到新URI
        302 临时移动，资源只是临时被移动，客户端可以继续使用原有URI
    4**：请求错误
        （开门的例子：400要用钥匙开门，你拿了个铁片，401：需要你输入密码来验证开门，403：知道你想开门，门不开）
        400：客户端请求的语法错误，服务器无法理解
        401：请求要求用户的身份认证
        403：服务端理解客户端请求，但是拒绝执行此请求
    5**：服务器错误
        500：服务器内部错误，无法完成请求
        502：充当网关或代理的服务器，从远端服务器收到一个无效请求


五大浏览器：
内核介绍
　（1）浏览器内核分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。
  （2）渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。
    （3）JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。
    （4）最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。

 内核的分类
　　（1）Trident (IE内核)
        国内很多的双核浏览器的其中一核便是 Trident，美其名曰 "兼容模式"。
　　　　代表： IE、傲游、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。
　　　　Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。
　　（2）Gecko(firefox
　　　　 Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁。

　　（3）webkit(Safari)
　　　　Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。
　　　　代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器。

　　（4）Chromium/Bink(chrome)
　　　　在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。
　　　　大部分国产浏览器最新版都采用Blink内核。
　　（5）Presto (Opera)
　　　　Presto 是挪威产浏览器 opera 的 "前任" 内核，最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了

　　3、移动端的浏览器
　　移动端的浏览器内核主要说的是系统内置浏览器的内核。
　　目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。


Session 保存在服务端，把客户端信息记录在服务端，客户端再次请求，就在服务端查找。查找客户端sessionid，有就找对应的，没有就创建。客户端保存sessionId的就是Cookie
Cookie 客户端请求服务器。若服务器要记录该用户状态，通过set-cookie这个响应头，响应客户端，客户端把Cookie保存起来，当浏览器再次访问该网站时，浏览器把请求的网络地址连同Cookie交给服务器，服务器检测来辨认用户状态

expires设置cookie的过期时间，expires缺省表示会话cookies、在浏览器关闭失效，与会话Cookie相对的是持久性cookies保存在用户硬盘，
max-age用于设置cookie失效之前需要经过的秒数，为正数：持久化，为负数会话cookie，为0立即删除这个cookie
加入Max-age和expires一起存在，max-age优先级更高。

人为的把客户端cookie禁止，禁止了就无法使用SessionID？
    1：URL重写把SessionID直接附加值URL路径后面
            http://../xxx;Sessionid=ByOKfdfdfdgdfgfgf;
            或者http://../xxx？Sessionid=ByOKfdfdfdgdfgfgf作为查询字符串/参数放在后面
    2：隐藏字段（表单）服务器自动修改表单，添加一个隐藏字段，以便表单提交时可以把sessionid提交到服务端
                 Cookie                             Session
有效期：          有效期之前有效                    超时失效（服务器定时清除不活跃的SessionId | 主动失效（调用HttpSession.invalidate(),
存储位置：        存在客户端                        服务端
安全：          保存浏览器，内容可见，客户端程序可能窥探或修改Cookie              对客户端来说是透明的，不存在敏感信息泄露的风险        
对服务器压力：
大小：  不超过4kb、
编码：
    码：字符集。
计算机如何显示文字?
    二进制保存，处理数据，
    国际组织制定了编码规范，不同二进制数表示不同字符：
        字库表：一套编码规范包括世界上所有的字符，每套编码规范都有自己使用的场景，字库表存储了编码规范中所有能显示的字符，计算机根据二进制数在字库表中找到对应字符显示在屏幕上。
        字符集：在字库表里每个字符都有一个对于应的二进制地址，字符集就是这些地址的集合。
        编码方式：编码规范如：Unicode，GBK，ASCII，ISO-8859-1，互不兼容，不同编码方式占用的空间不一样。utf-8不是编码规范，是个编码方式，面向全世界。
    乱码由来？
        乱码就是编码和解码使用的编码方式不一致，或者编码的时候在字符表里不存在这个字符

    URL的编码与解码
        URL采用ASCII字符集进行编码的，所有如果URL中包含非ASII字符集中的字符，要对其进行编码
        URL中一些保留字符，如“&”表示参数分隔符，如果要在URL中使用，就要编码。
Http身份认证
    身份认证信息
        密码
        动态令牌
        数字证书
        生物认证
        IC卡等
    Http常用认证方式
        1：BASIC认证，Http1.0定义的
            客户端发送请求，服务器返回401，告知用户验证，客户端携带用户名密码（将用户名密码base64处理，写入到首部字段，Authorization：Basic 编码后的用户名：密码。服务端接收到请求，去验证，验证通过返回200，失败401。
            BASIC认证虽然采用的是base64编码方法，但不是加密，安全性不高
        2：DIGEST认证：http1.1.。弥补basic认证。DIGEST认证同样使用质询/响应的方式，但不会像BASIC认证那样直接发送明文密码。
                   服务器同样返回401和临时质询码（随机数），客户端返回响应中包含DIGEST需要的字段（经过md5加密的密码），提供了保护密码的机制，但是防止不了用户伪装
        3：SSL客户端认证：是借由HTTPS的客户端证书来完成认证的方式，凭借客户端证书认证，服务器可确认访问是否来自于自己登录的客户端。
                    接收到需要认证资源的请求，服务器会发送一个satificate-requist的报文要求客户端提供客户端证书，用户选择将发送的客户端证书之后，客户端会把客户端证书信息以client-satificate这种报文的形式发送给服务器，服务器验证客户端证书，验证通过后可以领取证书内客户端密钥，开启https的加密通信。一般银行/金融才会使用，要一定的成本
            BASIC和DIGEST基本不使用，SSL客户端认证虽然有一定的安全等级，但是导入以及维持费用这些问题，不是所有网站都用，很多网站用基于表单认证
       4：基于表单的认证：该方法并不是在http中定义的。使用由web应用程序各自实现基于表单的认证方式，通过Cookie和Session的方式来保持用户状态


Http长连接/短连接
    能一次性节约很多资源，服务很多次的就是长连接，
    http协议是基于请求/响应模式，因此只要服务端给了响应，本次Http请求就结束了，。
    http长连接和短连接本质是TCP长连接和短连接，因为，tcp是双向通道，可以保持一段时间不关闭。
    Tcp就像装载货物（数据包）的车辆，Http就像交通规则。
    Http1.0中，默认短连接，可以使用connection和keep-alive首部
    http1.1起就默认用长连接。
HTTP中介-网关
    网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法。网关是资源和应用程序之间的粘合剂。网关扮演的是“协议转换器”的角色。
    WEB网关：
        WEB网关在一侧使用HTTP协议，在另一端用另一种此协议（《客户端协议》/《服务器端协议》
        Http/服务端网关：通过http于客户端对话，通过其他协议与服务器通信
        /Http客户端网关：通过其他协议与客户端通信，通过HTTP与服务器通信
    常见网关类型：
        Http/* 服务器端Web网关
        Http/Https服务端安全网关
        Https/Http客户端安全加速器网关
Http缓存
    Http缓存头部字段
        Cache-Control：请求/响应头，缓存控制字段
        no-store所有内容不缓存，
        no-cache（缓存，但浏览器使用缓存前，都会请求浏览器判断缓存资源是否是最新）
        private只要客户端可以缓存，代理cdn都不可以
        public客户端和代理服务器（CDN）都可以缓存
        
        Expires，响应头，代表资源过期时间，有服务器返回提供1.1提供 ，在于max-age共存情况下，优先级要低。
        
        Last-Modified响应头，资源最新修改时间，由服务器告诉浏览器
        if-Modified-since请求头，资源最新修改时间，由浏览器告诉服务器，和Last-Modified是一对，他它会进行比较。
       
        Etag响应头，资源标识，由服务器告诉浏览器
        if-None-Match请求头，缓存资源标识，由浏览器告诉服务器（其实就是上传服务器给的Etag），和Etag是一对，进行比较。用法比If-Modified-since高级
HTTP缓存工作方式：
    场景一：让服务器与浏览器约定一个文件过期时间Expires，浏览器再次发送请求前会对比Expires，看当前时间是否过期，过期发起请求，为避免文件没有修改，进入场景二
    场景二：让服务器与浏览器在约定文件过期时间的基础上，再加一个文件最新修改时间的对比，Last-Modify与if-Modify-Since
    浏览器可以随意修改Expires，Expires不太稳定。再很极端情况下 If-Modified-since只能精确到秒，如果文件在一秒内发生改变，Last-Modified无法感知改变，永远拿不到文件。因此进入场景三
    场景三：让服务器与浏览器在过期时间Expires+Last-Modified的基础上，增加一个文件内容唯一对比标识-Etag与If-None-Match，Expires不稳定，再加一个max-age来加以替代（Expires+Last-Modified+max-age+Etag
    缺陷：max-age或者Expires不过期，浏览器无法感知文件变化，怎么让浏览器无法感知？
Http缓存改进：
    1：md5/hash缓存
        通过不缓存html，为静态文件添加MD5或hash标识，解决浏览器无法跳过缓存过期时间，主动感知文件变化的问题。
        实现原理：上面通过对比Etag/if-none-match，前提是文件名一致，如果文件修改了，把文件名换了，因为浏览器中没有缓存改了之后的文件，所以又会请求服务器，能从根本上解决过期时间还没到，浏览器无法主动请求服务器这个问题。所以我们只要在项目每次发布迭代时候将修改过的文件添加md5或者hash标识。用一些工具添加
    2：CDN缓存
        CDN是构建在网络之上的内容分发网络，依靠部署在各地边缘服务器，通过中心平台的负载均衡，内容分发，调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。
        例如：以前只有一个火车售票点，所有人要去火车站买，人流量可想而知，之后各个区域都有代理火车票售卖点，代理售卖点就像CDN节点也就是代理服务器，可以把CDN理解为浏览器和服务器的临时站点，帮助服务器处理部分请求。
        CDN通过分流，跨地区访问
        CDN缓存工作方式：
         服务器将文件交给CDN进行缓存，客户端再次请求时找CDN，没有改变直接返回，改变了CDN找服务器获取最新内容再返回给客户端。
    CDN缓存和http缓存一样，过期时间没到就不能再次请求，缓存本身针对更新频率不高的文件，其次CDN提供了分流，以及访问加速。CDN和Http不一样的是CDN类似一个平台，可以通过登录手动更新CDN缓存，变相解决了浏览器缓存无法手动控制。

浏览器操作对Http缓存的影响
    用户操作            Expires/Cache-Control            Last-Modified/Etag
    地址栏回车              有效                           有效
    页面链接跳转            有效                           有效 
    新开窗口                有效                           有效
    前进后退                有效                           有效       
    F5刷新                  无效                            有效
    Ctrl+F5刷新             无效                            无效
    
内容协商机制
    访问同一个地址，在国内显示中文，在美国显示英语，用户只要访问就会显示对应资源。。
    内容协商机制指客户端和服务器就响应的资源内容进行交涉，然后提供给客户端最为合适的资源，内容协商会以响应资源的语言，字符集，编码方式等作为判断的基准
内容协商方式
    客户端驱动：客户端发起请求，服务端发送可选列表，客户端选择后再发送第二次请求。因为两次请求，延时
    服务器驱动：服务器检查客户端的请求头部集并决定提供哪个版本的页面。更快点。缺点：头部都不匹配的时候要猜测
    透明协商：某个中间设备（通常是缓存代理）代表客户端进行协商。
服务器驱动内容协商-请求首部集
    Accept：告诉服务器发送何种媒体类型
    Accept-Language：告诉服务器发送何种语言
    Accept-ChartSet 何种字符集
    Accept-Encoding何种编码

断点续传/多线程下载
    Http是通过在header里面两个参数实现的，客户端发请求时对应的是Range，服务器端响应时对应的是Content-Range
    Range用于请求头，指定第一个字节的位置和最后一个字节的位置，一般格式：
        Range:(unit=first byte pos) - [last byte pos]
        Range:bytes=0-499
        Range:bytes=500-600,601-999
    Content-Range用于响应头
        Http1.1 200 OK 不用断点续传
        Http1.1 206 Partial Content 使用断点续传
    客户端下载一个1024k的文件，已经下了512k，网络终点，客户端请求续传，在Http头部声明本次需要续传的片段：Range：bytes=512000-
    服务端传输并在响应头加Content-Range：bytes=512000-/1024000 返回206状态码

HTTPS
    与HTTP虽然都是网络传输协议，本质不同。
    HTTP不够安全，因为传输是以明文的方式，不做任何加密。有可能会被中间人拦截到数据包，进行篡改。
        对明文加密？加密：对称加密（加密解密都用一个密钥），非对称加密（使用不同密钥）。
            对称加密：中间人一开始就把密钥拦截呢？
            非对称加密：中间人虽然不知道一方的私钥是什么，但是它可以截获公钥后生成自己的公钥和私钥，发给另一方
        证书颁发机构（证书颁发机构、服务端网址、机构私钥加密（服务端公钥）、机构私钥加密（证书签名）
            服务端将自己的公钥key1发给证书机构，证书机构用自己的私钥加密key1，通过服务端网址等信息生成一个证书签名，证书签名同样经过私钥加密，服务端把加密后的证书签名发送到客户端，客户端去证书机构验证证书签名的真伪，客户端只要知道是哪个机构颁发的证书，就可以从本地找到对应的机构公钥解密出证书签名，客户端使用同样的签名规则，自己生成一个证书签名，如果两个签名一致，说明证书有效。客户端就可以用公钥解密出服务端的公钥key1.客户端用同样的办法生成对称加密的密钥key2，用服务端公钥key1加密key2，发给服务端，服务端用自己的私钥进行解密。
        中间人也像权威机构申请证书，并把服务端证书换成自己的证书呢？
            证书签名是由服务端网址等信息一起生成的，并且通过机构私钥加密，中间人无法篡改的，发给客户端的假证书也验证不通过。这是Https主题思想。https是在http的基础上增加了一个安全层。这一系列认证加密都是在这个安全层完成的。
Https可以认为是HTTP+TLS
    TLS是传输层加密协议，它前身是SSL
    SSL在HTTPS中建立在应用层和传输层之间，在TCP之上增加了一个加密通道。
Https提供了三个比较强大的功能来对抗劫持行为
    1：内容加密
        对称内容加密
        非对称密钥交换（可以截获key1，换成key3）
    2：身份认证
        数字证书（申请证书）
    3：数据完整性

HTTPS使用成本
    证书费用以及更新维护（不太高）
    HTTPS降低了用户访问速度（
    
Https对性能的影响
    1：协议交互所增加的网络RTT（往返时延，发送到收到确认总共延迟）
    2：加密解密带来的耗时。
Http访问过程
    三次握手建立连接-发送数据
Https访问过程
    三次握手建立连接-http get请求，服务端返回302跳转到https（考虑到用户不会输入https全称访问，只能使用302强制跳转），302跳转到https服务器端口不一样，要重新三次握手建立连接，TLS完全握手阶段（完成加密协商，证书身份确认，服务端和浏览器会协商出来相同的密钥加密算法，对证书签名算法，浏览器获取到证书之后也要校验证书有效性，浏览器首先获取证书里CA域名，如果CA域名没有命中缓存的话，浏览器需要解析CA域名的DNS，DNS解析后三次握手建立CA站点的TCP连接，浏览器发送ocsp（在线状态证书协议）请求获取响应），TLS完全握手阶段2，浏览器服务器进入应用层。

影响http网络请求的因素：
    http瓶颈：
        带宽
        延迟
        一条连接上只可以发送一个请求。
            （http1.1：每次发送请求都要重新连接增加大量延迟时间，传输数据时候都是明文，客户端服务器端无法验证彼此身份，在一定程度上无法保证数据安全性。当然我们通过https会话层的加入有效解决了这个问题，还有header携带的内容特别大，在一定程度上增加了成本，并且每次请求header基本不怎么变化，这在移动端就会增加用户的流量。支持keepalive来弥补多次连接造成的延迟，但是keep-alive使用多了同样对服务器带来大量的性能压力。并且对于单个文件被不断请求的服务，keep-alive会极大的影响性能。）
        请求只能从客户端开始，客户端不可以接受除响应以外的指令
            （比如我们想实时查看抖音视频更新，服务器一有内容就更新，把内容反馈到客户端，http请求只能从客户端发起，要频繁的客户端向服务端确认，人如果没有更新内容，不断确认是徒劳的。）
        请求/响应头部不压缩就发送
        每次互相发送相同头部造成浪费较多
        非强制压缩
双工WebSocket
    WebSocket可以看成是http为了支持长连接打的补丁，和http有些共性，是http本身无法解决的瓶颈而做出的改良。
    WebSocket可以看成一个新协议，基本没很大关系，只是为了更好的支持兼容http握手的规范而有那么一点交集。所谓的基于只是为了兼容。
    WebSocket是持久化的协议，相对于http这种非持久化的协议来说是持久的。例如：http1.0中，请求-响应。http1.1中改进有keep-alive，在一个http连接中可以发送多个request，接收response。这个response只能被动发送。
    Websocket是基于http协议的，或者是借用http来完成部分握手。
Ajax轮循：客户端隔一段时间询问服务器是否有新数据
长轮询：Long Poll 原理和Ajax轮循差不多，不过是阻塞模型（如果没消息服务端就等着消息），需要服务器有很快的处理速度的资源，追求速度
    这两种方式都是在不断地建立http连接，等待服务端处理，需要有很高的并发，也就是同时接待客户的能力要很强，追求容量。
    缺陷：非常消耗资源。
当服务器完成协议升级后，服务端可主动推送消息到客户端。
WebSocket特点：
    是真正的双工方式（需要对客户端服务端都升级），
    减少通信量，
SPDY
    Google提出，是http的，基于TCP会话层的协议，目的：最小化网络延迟，提升网络速度，对http的增强。
    HTTP：Http-TCP-IP
    SPDY：Http-SPDY-TLS-TCP-IP
    SPDY：
        1：多路复用请求优化，SPDY规定在一个SPDY连接内可以有无限个并行请求。多个并发请求共用一个连接。SPDY还可以设置优先级，不像HTTp那样先进先出。解决了非重要资源占用通道。
        2：支持服务器推送数据。SPDY压缩了http头，
        3：舍去了不必要的header信息。
        4：强制使用SSL传输协议
SPDY对普通用户来说，网页刷新变得更快，网站信息加密传输后不用担心信息被截取。

Http2.0
    Http2.0 ———TLS=optional————TCP————IP
    HTTP————SPDY————TLS————TCP————IP
Http2.0性能增强的核心：二进制分帧
    和http1.0完全不一样的地方：二进制分帧技术，在不改变http语义，状态码，方法，utI，首部字段等等核心概念下，做出了突破http1.1标准的性能限制，改变传输性能，实现低延迟高吞吐量。之所以叫2.0就是因为增加了二进制分帧。
        将所有的传输信息分割成更小的消息和帧，并且采用二进制形式编码。1.0.首部消息封装到headers Frame，1.1，中的requestbody中的msg封装到DATA frame
    http2.0首部压缩：首部表跟踪/存储之前发送键值对，相同的不再通过每次请求和响应发送。其实就是只发送发生变化的字段。通信双方缓存了一份首部表，即避免了重复header的传输。
http2.0多路复用：
    继承SPDY协议，所有通信都在一个TCP连接中完成。2.0把http基本单位缩小为帧。TCP性能：关键在于低延迟，大部分TCP连接很短，突发性。TCP只在长时间传输连接，传输大文件的时候效率才最高。2.0就让所有数据流公用一个TCP连接，可以更有效使用TCP，让高带宽也能服务HTTP性能提升。
单连接多资源优势：
    1:可以减少服务器压力，内存占用减少了，连接吞吐量大了
    2：由于TCP连接减少而使网络拥塞状况得以改善
    3：慢启动时间减少，拥塞和丢包恢复速度更快。
并行双向字节流的请求和响应：信息可分解为互不依赖的帧，在另一端把他们重新组成起来，同一个连接上有不同方向数据流在传输，所以客户端可以乱序发送数据流。也可以接收乱序流。
并行交错的发送请求，请求之间互不干扰
并行交错的发送响应，响应之间互不干扰。
只使用一个连接就可以并行发送多个请求和响应
消除不必要的延迟，减少页面加载事件。
请求优先级：高级优先级的流都应该优先发生，优先级不是绝对的。不同优先级混合也是必须的。
服务器推送：

HTTP2.0的问题：还是底层支称的TCP造成的，
    1：队头阻塞（当连接中出现丢包，http2.0不如http1，丢包之后整个tcp都要等待重传，导致后面数据被阻塞，对于http1.1来说，开启多个tcp连接，出现这个问题只会影响单个连接。）
    2：建立连接的握手延迟：不管是1.0还是1.1，https都是tcp进行传输，https，2.0还要使用TLS进行安全传输，这样出现两个握手延迟。TLS完全握手至少需要RTT两回才能建立，对于短连接来说，这个延迟影响很大无法消除。
QUIC是TCP遗留的无法解决问题的优化。
    针对延迟问题：0 RTT ：QUIC利用类似TCP快速打开的技术，缓存当前会话上下文，下次恢复绘画时候只要将会话缓存传到服务器确认，确认通过就可以进行传输。
        传统TCP：客户端————服务端————响应客户端（1RTT）————客户端发送ACK+SYN————服务端响应（2RTT）
        TCP+TLS：4RTT
        QUIC：2RTT

浏览器缓存分类：
强制缓存：浏览器在加载资源的时候会先根据本地缓存资源的header中的信息（expires和cache-control）判断是否命中强缓存，命中就直接使用缓存中的资源，不像服务器发请求
Cache-Control
Cache-Control 是 http1.1 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：

no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。

no-store：禁止使用缓存，每一次都要重新请求数据。

public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。

private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。

Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。
协商缓存：当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。

这里的 header 中的信息指的是 Last-Modify/If-Modify-Since 和 ETag/If-None-Match.

Last-Modify/If-Modify-Since
浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。

当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。

如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。

缺点:

短时间内资源发生了改变，Last-Modified 并不会发生变化。

周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为,因此便有了 ETag。

ETag/If-None-Match
与 Last-Modify/If-Modify-Since 不同的是，Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存。

与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。

Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。

浏览器缓存优点：
    1：减少了冗余的数据传输
    2：减少了服务器的负担，大大提升了网站性能。
    3：加快了客户端加载网页的速度。