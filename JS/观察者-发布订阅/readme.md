出版社+订阅者=观察者模式



有一个改变天气的函数，有一些天气，温度属性，如果我们想要增加湿度，还得改函数里面代码，这就是紧耦合的坏处
观察者模式：面向接口编程，实现松散耦合，
被观察者要维护一套观察者的集合，这些观察者实现相同的接口，subject只需要知道，通知观察者时候需要调用哪个统一方法就好了

警察抓人，小偷是被观察者，被观察者维护一套观察者的集合。小偷做出偷东西这个举动，警察是观察者，观察者有很多方法（'监听，逮捕，枪杀）等方法


观察者模式中观察者和被观察者直接联系，没有中间人，属于松耦合



发布订阅模式promise
发布者不会直接去通知订阅者，而是通过中间代理，不是松耦合，而是完全解耦

publisher ----TopicA -----subscriber
发布者告诉中间人，我发布的消息是AA，订阅者告诉中间人，我订阅的是BB消息，还有AA消息
一旦中间人发现有订阅者订阅的消息就推送给订阅者

document.body.addEventListener()这里的document.body就是事件的发布者
addEventListener就是事件，发布者提供一个订阅事件的接口方法，所有其他对象都可以调用这个方法来订阅document.body上发生的对应事件

发布和订阅是一对多的关系
发布订阅模式优点：
1，支持简单的广播通信，当对象发生改变，会自动通知订阅者
2.发布订阅模式完全解耦，发布者不是直接通知订阅者，而是通过中间代理

对于优点1，工作中ajax请求，有请求成功和失败的回调，我们可以订阅ajax的success和error事件，我们不必关系对象在异步运行的状态，只关心是success还是error，然后执行不同的任务

发布订阅缺点：
1.创建订阅者需要消耗一定的时间和内存
2.虽然可以弱化对象之间的连续，如果过度使用，反而让代码不好理解和维护


实现发布订阅：
1.明确谁是发布者，
2.给发布者添加一个缓存列表(调度中心），用于存放回调函数来通知订阅者
3.发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数


为什么用这种模式？
如果一个数据发生变化，回对很大事件产生影响，如：通过websocket从后台实时获取数据，当返回的数据为@end
，需要执行关闭数据流，更该数据显示，更新设备状态等待，在不使用订阅模式时，
收到@end后我们注册一个函数，需要在该函数写n个函数执行，但是用设计模式，只需要注册一个@end的发布函数，其他函数订阅该函数，当发布函数发布信息，其订阅者自动更新

