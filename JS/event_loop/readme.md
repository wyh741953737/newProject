一、进程和线程

    进程：程序的一次执行（单/多进程）
    线程：一个进程包含1到多个线程，程序是在某个进程中的线程里执行的，线程是程序执行的一个完整流程，是进程中的一个独立的单位
        多线程能有效提升CPU利用率，缺点是线程之间切换开销大，死锁与状态同步问题。

    内核：IE：Trident，Chrome，safari是Webkit，firefox：Gecko
        内核由很多模块组成：js引擎模块，html，css文档解析（主线程），DOM，CSS模块，定时器模块（分线程），网络请求模块，Dom事件模块，布局和渲染模块

二、event-loop

    event-loop：事件轮循，是异步的解决方案。
    代码分为初始化代码和回调代码，js引擎执行代码流程：先执行初始化代码，后面中某个时刻执行回调代码
    js实现异步的具体方案：
        同步代码直接执行，异步代码放在异步队列等待同步队列执行完，轮循执行异步队列中的函数。
    主要分为三部分：主线程，宏队列，微队列
    1：主线程：js引擎（heap，stack）
        js引擎是单线程的，先执行所有同步代码，再执行异步队列（先执行微队列，再执行宏队列）中回调函数
        js引擎为什么单线程？
            js主要用来处理用户与页面产生交互以及DOM操作，如果是多线程，一个线程要删除该DOM，一个线程要修改，听谁的？浏览器内部不是单线程，浏览器内部有JS引擎线程，事件触发线程，定时器线程，异步http请求线程，GUI渲染线程。
        分线程：浏览器的Web APIS管理模块（DOM事件管理模块，ajax回调管理模块，定时器管理模块，promise管理模块，Mutation回调管理模块）
    2：宏队列：dom事件回调，ajax回调，定时器回调
    3：微队列：promise回调，mutation回调

三、WebWorkers
    H5规范提供的JS分线程的实现（多线程的终极解决方案）
        相关API：Worker：构造函数，加载分线程执行的js文件
                Worker.prototype.onmessage用于接收另一个的回调函数
                worker.prototype.postmessage向另一个线程发送消息
    不足：webWorker内代码不能操作DOM（更新UI）（因为分线程中全局对象不再是window，不能跨域加载js，而且webworker不是每个浏览器都支持。
    进行计算时，主线程不停的计算，主界面无法操作，递归操作，将耗时的计算交给分线程webworker，但是该特性任然没有改变js单线程的本质

四、同步和异步
    同步指的是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。

    异步指的是每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。比如ajax请求数据，数据一次性请求，谁先返回先执行谁，不用等，

    首先js是单线程的语言。那Js如何实现异步的?异步和单线程不是自相矛盾吗？
    单线程和异步确实不能同时成为一个语言的特性。js选择了成为单线程的语言，所以它本身不可能是异步的，但js的宿主环境（比如浏览器，Node）是多线程的，宿主环境通过某种方式（事件驱动，下文会讲）使得js具备了异步的属性。
    浏览器的内核是多线程的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：javascript引擎线程，UI渲染线程，浏览器事件触发线程。


    1.javascript引擎线程是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。

    2.UI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意 UI渲染线程与JS引擎是互斥的，当JS引擎执行时UI线程会被挂起，UI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

    3.事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。

    1.Js创建了一个ajax请求
      2.浏览器另外开启一个ajax引擎线程，执行ajax请求
      3.执行得到响应后将回调函数放入任务队列中。
    4.Js执行任务队列中的回调函数。

    2.常见的异步：定时器、事件绑定都是异步1，ajax一般采用异步操作，也可以是同步（async：false，页面卡住），回调函数可以理解为异步（不是严谨的异步操作

五、如何写一个简单的异步操作?
    回调函数也相当于异步操作，所以可以在函数A里面回调函数B。
    定时器不能包证是定时执行，一般会延迟，定时器回调函数在主线程执行（js单线程）
    再问：如果俩个定时器操作耗时一样长或者一个比一个操作耗时稍微短，代码如何执行？
        异步操作总是将耗时的任务放在后面执行所以耗时短的将会在前面执行，如果耗时一样长则看函数的排序，或者是否回调。
    如何证明js单线程？
    定时器+alert（暂停当前主线程与定时器）

六、重绘和回流
    页面加载的时候，浏览器把HTML代码解析为DOM树，
    回流：元素规模尺寸，布局，隐藏等改变时候引起回流
    重绘：元素颜色，字体大小发生改变的时候引擎重绘
    回流可能会引起重绘，但是重绘不一定会引发回流。
